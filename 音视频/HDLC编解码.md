# HDLC编解码  


```c++
#include <stdlib.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <string.h>


typedef signed char int8_t;
typedef unsigned char   uint8_t;
typedef short  int16_t;
typedef unsigned short  uint16_t;
typedef int  int32_t;
typedef unsigned   uint32_t;


uint16_t m_fcs_tab[256]={
    0x0000,0x1189,0x2312,0x329b,0x4624,0x57ad,0x6536,0x74bf,
    0x8c48,0x9dc1,0xaf5a,0xbed3,0xca6c,0xdbe5,0xe97e,0xf8f7,
    0x1081,0x0108,0x3393,0x221a,0x56a5,0x472c,0x75b7,0x643e,
    0x9cc9,0x8d40,0xbfdb,0xae52,0xdaed,0xcb64,0xf9ff,0xe876,
    0x2102,0x308b,0x0210,0x1399,0x6726,0x76af,0x4434,0x55bd,
    0xad4a,0xbcc3,0x8e58,0x9fd1,0xeb6e,0xfae7,0xc87c,0xd9f5,
    0x3183,0x200a,0x1291,0x0318,0x77a7,0x662e,0x54b5,0x453c,
    0xbdcb,0xac42,0x9ed9,0x8f50,0xfbef,0xea66,0xd8fd,0xc974,
    0x4204,0x538d,0x6116,0x709f,0x0420,0x15a9,0x2732,0x36bb,
    0xce4c,0xdfc5,0xed5e,0xfcd7,0x8868,0x99e1,0xab7a,0xbaf3,
    0x5285,0x430c,0x7197,0x601e,0x14a1,0x0528,0x37b3,0x263a,
    0xdecd,0xcf44,0xfddf,0xec56,0x98e9,0x8960,0xbbfb,0xaa72,
    0x6306,0x728f,0x4014,0x519d,0x2522,0x34ab,0x0630,0x17b9,
    0xef4e,0xfec7,0xcc5c,0xddd5,0xa96a,0xb8e3,0x8a78,0x9bf1,
    0x7387,0x620e,0x5095,0x411c,0x35a3,0x242a,0x16b1,0x0738,
    0xffcf,0xee46,0xdcdd,0xcd54,0xb9eb,0xa862,0x9af9,0x8b70,
    0x8408,0x9581,0xa71a,0xb693,0xc22c,0xd3a5,0xe13e,0xf0b7,
    0x0840,0x19c9,0x2b52,0x3adb,0x4e64,0x5fed,0x6d76,0x7cff,
    0x9489,0x8500,0xb79b,0xa612,0xd2ad,0xc324,0xf1bf,0xe036,
    0x18c1,0x0948,0x3bd3,0x2a5a,0x5ee5,0x4f6c,0x7df7,0x6c7e,
    0xa50a,0xb483,0x8618,0x9791,0xe32e,0xf2a7,0xc03c,0xd1b5,
    0x2942,0x38cb,0x0a50,0x1bd9,0x6f66,0x7eef,0x4c74,0x5dfd,
    0xb58b,0xa402,0x9699,0x8710,0xf3af,0xe226,0xd0bd,0xc134,
    0x39c3,0x284a,0x1ad1,0x0b58,0x7fe7,0x6e6e,0x5cf5,0x4d7c,
    0xc60c,0xd785,0xe51e,0xf497,0x8028,0x91a1,0xa33a,0xb2b3,
    0x4a44,0x5bcd,0x6956,0x78df,0x0c60,0x1de9,0x2f72,0x3efb,
    0xd68d,0xc704,0xf59f,0xe416,0x90a9,0x8120,0xb3bb,0xa232,
    0x5ac5,0x4b4c,0x79d7,0x685e,0x1ce1,0x0d68,0x3ff3,0x2e7a,
    0xe70e,0xf687,0xc41c,0xd595,0xa12a,0xb0a3,0x8238,0x93b1,
    0x6b46,0x7acf,0x4854,0x59dd,0x2d62,0x3ceb,0x0e70,0x1ff9,
    0xf78f,0xe606,0xd49d,0xc514,0xb1ab,0xa022,0x92b9,0x8330,
    0x7bc7,0x6a4e,0x58d5,0x495c,0x3de3,0x2c6a,0x1ef1,0x0f78
};
uint8_t m_bit_mask[8]={
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
};
uint8_t m_flag_1st_mask[8]={
    0x7e,0x3f,0x1f,0x0f,0x07,0x03,0x01,0x00
};
uint8_t m_flag_2nd_mask[8]={
    0x00,0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfc
};
uint16_t CalFcs16(uint8_t *cp,int len)
{
    uint16_t fcs=0xffff;
    while(len--)
	fcs=(fcs>>8) ^ m_fcs_tab[(fcs ^ *cp++) & 0xff];
    fcs=(fcs>>8)+(fcs<<8);	// swap bytes
    return (fcs);
}

int Encode(uint8_t *io,int input_len,int buf_len)
{
    static unsigned trailing=0;
    static int start_bit=0;

    /* MSB                        LSB */
    /*  0   1   2   3   4   5   6   7 */
    uint8_t next_byte,data[512],*output,*input;
    int	bit1_count,save_bytes;
    uint16_t calculated_fcs;

    if(buf_len<(8+input_len*6/5)) return 0;  // output buffer not enough

    calculated_fcs=CalFcs16(io,input_len) ^ 0xffff;

    if(input_len+2>(int)sizeof(data)) return 0;

    memcpy(data,io,input_len);
    memset(io,0,buf_len);
    *(uint16_t*)(data+input_len)=htons(calculated_fcs);

    input_len+=2;

    save_bytes=0;
    output=io;
    *output=trailing;

    /* now put the flag,3 times */
    for(int i=0;i<3;i++) {
	*output|=m_flag_1st_mask[start_bit];
	save_bytes++;
	output++;
	*output=m_flag_2nd_mask[start_bit];
    }

    /* encode the input data,include the fcs */
    /* note: we should fetch 1 bit from the LSB of input,and put
       at the MSB of ouput */
    bit1_count=0;
    input=data;
    for(int i=0;i<input_len;i++,input++) {
	next_byte=*input;
	for(int j=7;j>=0;j--) {
	    if(next_byte & m_bit_mask[j]) {
		// get bit 1
		*output|=m_bit_mask[start_bit];
		start_bit++;
		if(8==start_bit) {
		    start_bit=0;
		    save_bytes++;
		    output++;
		}
		bit1_count++;
		if(5==bit1_count) {
		    // should insert a zero
		    start_bit++;
		    bit1_count=0;
		}
		if(8==start_bit) {
		    start_bit=0;
		    save_bytes++;
		    output++;
		}
	    }
	    else {
		// get bit 0
		bit1_count=0;
		start_bit++;
		if(8==start_bit) {
		    start_bit=0;
		    save_bytes++;
		    output++;
		}
	    }
	}
    }

    /* put flags at the end,4 times */
    for(int i=0;i<4;i++) {
	*output|=m_flag_1st_mask[start_bit];
	save_bytes++;
	output++;
	*output=m_flag_2nd_mask[start_bit];
    }

    trailing=*output;

    return save_bytes;
}

int Decode(uint8_t *input,int input_len,uint8_t *output,int *output_len)
{
    uint8_t tmp_byte,next_byte;
    int	tmp_byte_bit,bit1_count,net_bit_count,save_bytes;
    int	sync_found,valid_pkt_found;
    uint16_t trialfcs;

    if(*output_len<input_len){
        printf("buffer no enough,maybe overflow \n");
	    return 0;	// buffer no enough,maybe overflow
    }

    tmp_byte=0;
    tmp_byte_bit=0;
    bit1_count=0;
    net_bit_count=0;
    save_bytes=0;

    valid_pkt_found=0;
    sync_found=0;

    for(int i=0;(i<input_len) && (!valid_pkt_found);i++) {
	/* search the sync */
	next_byte=input[i];
	for(int j=0;j<8;j++) {
	    if(next_byte & m_bit_mask[j]) {
		// bit 1
		bit1_count++;
		if(sync_found) {
		    net_bit_count++;
		    tmp_byte=(tmp_byte>>1 )|0x80;
		    tmp_byte_bit++;
		}
	    }
	    else {
		// got bit 0
		if(bit1_count>6) {
		    //>6 1s
		    tmp_byte=0;
		    tmp_byte_bit=0;
		    net_bit_count=0;
		    sync_found=0;
		    save_bytes=0;
		}
		else if(6==bit1_count) {
		    // 01111110
		    sync_found=1;
		    net_bit_count++;
		    if(net_bit_count>=24 ) {
			valid_pkt_found=1;
			break;
		    }
		    else {
			// the continueous flag found
			net_bit_count=0;
			save_bytes=0;
			tmp_byte=0;
			tmp_byte_bit=0;
		    }
		}
		else {
		    if(sync_found) {
			if(5==bit1_count) {
			    // unpad 0
			}
			else {
			    net_bit_count++;
			    tmp_byte>>=1;
			    tmp_byte_bit++;
			}
		    }
		}
		bit1_count=0;
	    }

	    // check to see if the tmp_byte should save to buffer
	    if(8==tmp_byte_bit) {
		tmp_byte_bit =0;
		output[save_bytes++]=tmp_byte;
	    }
	}
    }

    net_bit_count-=8;     // minus the last flags
    if(0!=(net_bit_count & 0x7)){ // not byte aligned
        printf("not byte aligned \n");
	    return 0;
    }
    save_bytes-=2;       // exclude the fcs
    if(save_bytes<=0){
        printf("exclude the fcs \n");
	    return 0;
    }

    *output_len=save_bytes;
    trialfcs=CalFcs16(output,save_bytes);
    trialfcs^=0xffff;
    if(trialfcs!=ntohs(*(uint16_t*)(output+save_bytes))) {
       printf("decode fail\n");
       return 0;
    } 
//////////////////////////////
    printf("hex:   [");
    for(int i = 0 ;i < input_len; i++){
        printf("%02x ", input[i]);
    }
    printf("]\n");
    printf("decode:[");
    for(int i = 0 ;i < save_bytes; i++){
        printf("%02x ", output[i]);
    }
    printf("]\n");
    printf("decode success \n"); 
	return save_bytes;
}
int     buffer_encode_len[21] ={27, 23, 47, 26, 19, 23, 20, 20,19,19,20,19,19,20,19,19,19,19,19,20,19};
uint8_t buffer_encode[21][100]= {
    {0x7e,0x7e,0x7e,0x00,0x86,0xc0,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x00,0x40,0x81,0xf7,0x32,0x76,0x00,0x20,0x70,0x70,0x08,0x3f,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0xfb,0x32,0x76,0x00,0x20,0x04,0x01,0xc0,0x65,0xa1,0xbf,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0xfb,0x32,0x76,0x00,0x20,0x10,0x01,0xd5,0x1b,0x17,0x27,0x43,0x51,0x3b,0x13,0x07,0x7b,0x4b,0x3b,0x17,0x02,0x37,0x26,0x3a,0x06,0x3a,0x06,0x5a,0x16,0x66,0x46,0x46,0x18,0xe9,0x3f,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0xfb,0x32,0x76,0x00,0x20,0x50,0x01,0xf7,0xd8,0x00,0x00,0x1c,0x3e,0xc7,0xe7,0xe7},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0xa0,0x08,0x0e,0x45,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x86,0xc0,0x00,0x00,0x00,0x00,0x00,0x03,0x40,0x00,0x81,0xf4,0x54,0x07,0x9a,0x40,0x3f,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x80,0x03,0x10,0xf2,0xcc,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x80,0x01,0x10,0x94,0xae,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0xc0,0x01,0x94,0x46,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0xc0,0x40,0xcc,0xa3,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x80,0x0c,0x10,0xe2,0xf2,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0xc0,0x0c,0x45,0xeb,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0xc0,0x40,0xcc,0xa3,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x80,0x04,0x10,0x6b,0x5b,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x40,0x04,0xdf,0x3d,0xbf,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x40,0x04,0xdf,0x3d,0xbf,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x40,0x04,0xdf,0x3d,0xbf,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x40,0x04,0xdf,0x3d,0xbf,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x40,0x04,0xdf,0x3d,0xbf,0x3f,0x3f},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0x80,0x0c,0x10,0xe2,0xf2,0x7e,0x7e,0x7e},
    {0x7e,0x7e,0x7e,0x00,0x8e,0xc0,0x00,0x00,0x00,0x00,0x80,0x03,0xc0,0x0c,0x45,0xeb,0x7e,0x7e,0x7e}
};
int main(int argc, char** argv)
{
    /*uint8_t m_buf[512] = {0x00 ,0x71 ,0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x01 ,0x80 ,0x0c};
    uint8_t m_buf2[512] = {0xe7 ,0xe7 ,0xe7 ,0xe0 ,0x08 ,0xec ,0x00 ,0x00 ,0x00 ,0x00 ,0x08 ,0x00 ,0x08 ,0x00 ,0x13 ,0x02 ,0xb1 ,0x07 ,0xe7 ,0xe7 ,0xe7};
    uint8_t m_buf3[19] = {0x7e ,0x7e ,0x7e ,0x00 ,0x8e ,0xc0 ,0x00 ,0x00 ,0x00 ,0x00 ,0x80 ,0x03 ,0x40 ,0x04 ,0xdf ,0x3d ,0xbf ,0x3f ,0x3f};
    int m_data_len  =  Encode(m_buf,12,512);
    printf("encode:[");
    for(int i = 0 ;i < m_data_len; i++){
        printf("%02x ", m_buf[i]);
    }
    printf("]\n");*/

    
    for(int i = 0 ;i < 21; i++){
        if(buffer_encode_len[i] != 20)
            continue;
        printf("start i[%d] len[%d]\n",i, buffer_encode_len[i]);
        uint8_t debuf[512]  ={0};
        int     outputlen   =512;
        Decode(buffer_encode[i],  buffer_encode_len[i], debuf,&outputlen);
        printf("\n");
    }


}
```
