# linux-串口阻塞与非阻塞参数设置  

在串口设置中，有以下两个参数可以决定是否阻塞。  

在打开串口时不加O_NODELAY,可用下面的第二种方法，来进行阻塞/非阻塞的设定  

` c_cc[VTIME] 非规范模式读取时的超时时间(单位:百毫秒),可以这么理解，从接收到后一个字节开始计时，如果超时，则退出READ`

`c_cc[VMIN]  非规范模式读取时的最小字符数，设为0则为非阻塞，如果设为其它值则阻塞，直到读到到对应的数据`
  
关键代码:  

```c
iFd = open(cSerialName, O_RDWR | O_NOCTTY);                       

opt.c_cc[VMIN]   =   0;//DATA_LEN;                                     
opt.c_cc[VTIME]  =   30;//每个单位是0.1秒  20就是2秒
```

通过上面的设置，如果在 `len=read(fd, tmp,124);`   无任何数据，则会3秒钟后退出READ，但是如果串口有读取到数据则会立即返回  

c_cc[VMIN],就像一个阀值一样，比如设为8，如果只接收到3个数据，那么它是不会返回的，只有凑齐8个数据后一齐才READ返回，阻塞在那儿了.  

opt.c_cc[VMIN]   =   8;//DATA_LEN;  

opt.c_cc[VTIME]  =   30;//每个单位是0.1秒  20就是2秒    

如果这样设置，就完全阻塞了，只有串口收到至少8个数据才会对READ立即返回，或才少于8个数据时，超时3秒也会有返回  

再来说下 read(fd, tmp,xx);如果其中的xx设为1，则只要串口有一个数据，即使opt.c_cc[VMIN]=8，它也会立即返回，无需凑足8bytes,如果这个数为1024，只要实际接收的数据超出opt.c_cc[VMIN]设定的值后，也会立即返回，而不用凑足1024，我个人感觉这个值设为1比较好，用于阻塞方式的读取，如果非阻塞，当然是0  

O_NONBLOCK和O_NDELAY所产生的结果都是使I/O变成非搁置模式(non-blocking)，在读取不到数据或是写入缓冲区已满会马上return，而不会搁置程序动作，直到有数据或写入完成。  

它们的差别在于设立O_NDELAY会使I/O函式马上回传0，但是又衍生出一个问题，因为读取到档案结尾时所回传的也是0，这样无法得知是哪中情况；因此，O_NONBLOCK就产生出来，它在读取不到数据时会回传-1，并且设置errno为EAGAIN。  

不过需要注意的是，在GNU C中O_NDELAY只是为了与BSD的程序兼容，实际上是使用O_NONBLOCK作为宏定义，而且O_NONBLOCK除了在ioctl中使用，还可以在open时设定。  
  
  