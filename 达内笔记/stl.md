###### 模板
1. 为同一种算法，定义使用于不同类型的版本
2. 借助参数宏 摆脱类型的限制，同时也丧失了类型安全
3. 让预处理器根据一个通用的“模版宏” 生成针对不同类型的版本
4. 编写一个带有参数化类型的通用版本，让编译器自动生成针对不同类型的具体版本-----模版机制  

* 模版函数/函数模版 带有类型参数的函数。函数的返回值，参数及局部变量均可使用类型参数。函数模版支持隐式推断。
* 模版类（类模版）带有类型参数的类，类的成员变量，成员变量， 成员类型以及基类。类模版 不能做隐式推断。
* 模版的实例化 ：编译器用类型实参（显示/隐式）匹配模版中的类型实参后，生成的具体类或函数的过程。  

类模版-实例化 -》类-实例化-》对象  
            编译期          运行期  

###### 模版特化  
1. 可以为模版提供一种特殊化定义，作为一般情况之外的特例，为编译器提供一种更为合适的选择。
2. 对于类模版而言，既可以做全类特化，也可以指针对部分与类型相关的成员函数进行特化。对于后者一定要保证特化版本的接口规格与通用版本完全一致。  

###### 模块划分和编译模型  
1. 包含模型 ：在模版的声明文件中，在文件的末尾包含该模版的实现。强制模版的定义和实例化放在同一个编译单元中。  
    * 问题一：模版的实现部分必须对用户公开
    * 问题二：增加编译时间。  
2. 导出模型：在模版声明之前加上export关键字，表示该模版将在定义模块之外被实例化。  

```c++
export template<...>
        void foo(void){...}
export template<...>
        class{...}
```
   问题：几乎没有编译器持支这么用法，只有Edison Design Group，Inc公司的编译器支持，其他不支持这样用法。  
   C++2011标准中 中已经放弃了

###### 局部特化  
1. 对于具有多个类型参数的类模版，可以只特化其中的一部分类型参数。编译器会优先选择特化程度最高的版本。
2. 对于具有多个类型参数的类模版，可以针对类型参数之间某种特殊关系进行特化。编译器优先选择匹配成对最高的版本。
3. 对于类模版，可以针对指针或数组进行特化。编译器会优先选择针对指针和数据的特化。
4. 函数模版不能做局部特化
5. 反之由局部特化引起的实例化匹配冲突。
`smart_ptr`  

###### 非类型参数  
1. 除了类型参数以外，模版也可以接受非类型参数。
2. 传递给模版的非类型参数只能是常量，常量表达式或者具有常属性（const）的变量，但是不能被volatile（挥发性修饰）修饰
3. 函数模版和类模版都可以带有非类型参数。  

###### 缺省参数  
1. 无论是类型参数 还是非类型参数都可以带有缺省值，如果实例化模版时没有提供相应的模版实参，该参数就取缺省值。
2. 如果某个模版参数带有缺省值，那么该参数后面的所有参数必须都带有缺省值。
3. 后面参数的缺省值可以引用前面参数的值。
4. c++98中只有类模版可以带有缺省参数，函数模版不能带有缺省参数（为了避免和隐式推断混淆）  

###### typename 和class  
  class        - 表示类  
                  - 表示模版的类型参数                    
 typename- 表示模版的类型参数  
                    - 表示依赖类型                      
 依赖类型：

```c++
template<typename T>
void foo(void){
    typename T::UNIT x;
    typename T::Student;
}
```

###### 其它细节  
1. 从基模版继承  
     在子模版中访问基模版的成员类型，成员函数，成员变量，需要使用作用域限定符（::），或者使用this指针  
2.  模版型 模版参数  

```c++
template<typename K, typename V,template<typename T> class E>
class Pair{
public:
   Pait(const K& key,const V& val):m_key(key),m_val(val){}
   E<K> m_key;
   E<v> m_val;
};
```
3. 模版的模版成员
4. 模版的递归实例化 `Array<List<int>,10>`


###### 容器和迭代器  
1. 容器：泛型化的数据结构，通过一套统一的标准接口为用户提供不同的逻辑功能，如QList，list等
2. 迭代器：通过一个抽象类型，使用户可以通过一组一致且透明的方法，以统一的方式访问不同容器中的数据，为泛型算法提供支持。  

###### 案例：链表  
1. 直接构造空链表
2. 支持深拷贝的拷贝构造 和 拷贝赋值
3. 提供一组操作接口，如：front/push_front/pop_front     back/push_back/pop_back
4. 支持内置的迭代器类型，以及基于迭代器的插入和删除操作  

###### STL 概述  
1. 标准模版库 主要包括三个部分  
    * 容器：存储 和管理对象的集合。数据结构的泛型化封装
    * 迭代器：在不暴露容器内部实现细节的前提下，为用户提供访问容器中数据元素的统一方法。
    * 泛型算法：借助迭代器，以泛型的方式操作容器中的数据元素。  
2. STL的所有组件都是通过模版定义的。支持对数据类型的泛化。
3. STL所强调的是将数据结构和算法与具体的数据类型独立开来。
4. STL所追求的是在尽量小的框架内实现最大的弹性。  

###### 十大容器  
1. 线性容器：向量(vector) , 列表(list) , 双端队列(deque)
2. 适配器容器:堆栈(stack) ,队列(queue) , 优先队列(priority_queue)在线性容器基础上进行封装
3. 关联容器：映射(map),多重映射(multimap),集合(set) ,多重集合(multiset)  

###### STL容器的共性  
1. 所有的STL容器都提供支持深拷贝的拷贝构造函数和拷贝赋值运算符函数。但是容器中的元素类型也需要支持深拷贝。
2. 容器之间可以进行相等和不等的判断。容器判断的条件是：容器和元素类型都相同，容器中元素的个数也要相同。对应元素满足==运算。
3. 容器中保存的永远是被放入对象的副本，而非其本身。
4. 容器中不要放入auto_ptr。  

######  向量 vector  
1. 基本特征  
    *  用连续的地址空间存放数据元素，因此支持通过下标随机访问其中的元素。        
    *  动态内存管理，随着新元素的不断加入，其内存空间自动增长（但是不能自动收缩）。
    * 通过预分配空间降低动态内存管理的开销。
    * 支持在随机位置的插入和删除 但是只有在接近容器尾端进行操作效率才比较高。  
2. 实例化`#include <vector>`  
    * 空向量  
        ```c++
       vector<元素类型> 向量对象;
       vector<int> vi;
        ```
    * 定义有初始大小  
        ```c++
       vector<元素类型> 向量对象(初始大小);
       vector<int> vi(10);
       //基本类型：用0初始化，
       //类类型  ：用缺省构造初始化。
        ```
    * 在指定初始大小的同时指定初始值  
        ```c++
       vector<元素类型> 向量对象(初始大小,初值);
       vector<int> vi(10,5);
        ```
    * 通过其它容器初始化  
        ```c++
       int a[5]={12,23,44,18,37}:
       vector vi(&a[0],&a[5]);
        ```
3. 迭代器  
    * 四个迭代器  
        ```c++
        正向迭代器:iterator
        常正向迭代器:const_iterator
        反向迭代器:reverse_iterator
        常反向迭代器:const_reverse_iterator
        ```  
    * 随机迭代器相对于顺序迭代器而言，增加以下功能：  
        * 和整数的加减运算：
        * 同型迭代器之间的比较和相减运算。
4. 常用成员函数  
    ```c++
     value_type& front(void);
     const value_type& front(void) const;
     value_type& back(void);
     const value_type& back(void) const;    
    ```
  一个模版类中可否包含虚汗数？  
  * 不包含比类模版更多的类型参数的成员函数是虚汗数
  * 但是如果该成员函数包含了比类模版更多的模版参数，那么它就不能被声明为虚汗数  
5.  注意迭代器的有效期。  
       任何可能导致容器结构发生变化的函数（push_back,insert,pop_back/erase/sort等等）被调用，先前获得的迭代器都可能因此而实效，重新初始化以后再使用才是安全的。  
6. 大小和容量  
    ```c++
    //大小: 实际容纳元素的个数
    //容量：最多容纳元素的个数
    size_type size(void) const; //获取大小
    void resize(size_type num,const value_type& val=value_type())
    //改变大小，可增 可减， 增构造  减析构，第二个参数表示新增元素的初始值，不指定第二个参数就是缺省方式初始（0/缺省构造）

    void  clear(void); //清空 相当于resize（0）；
    bool empty(void) const; //判空 空则返回true ，否则返回false;
    size_type capacity(void) const //获取容量
    void reserve(size_type size); //改变容量，只增不减，新增部分不做初始化
    ```  
对于容量以内，大小以外的元素可以访问，但其值并不稳定，随时可能因后续操作而发生改变。  
无论是通过成员函数减少容器中的元素，还是通过reserve（）直接修改容器的容量，容量都是只能增加不能减少的，因此，对于持久化的向量容器，不适合存放太多的大对象。如果元素对象需要比较多的内存资源，建议采用动态分配的方式，在构造和析构函数和中自己管理，或者使用string等其他容器自动管理。  

7. 查找和排序  
    ```c++
    #include <algorithm> 
         //iterator find(iterator begin,iterator end,const value_typpe& val)
         //在从begin开始到end之前的元素为止，第一个与val匹配的元素的迭代器。如果查找失败 返回end
         #include<algorithm>
         int a[6] ={1，2，3，4，5，6};
         vector<int> vi(a,a+6);
         vector<int>::iterator it = find(vi.begin(),vi.end,33);
         if( it  == vi.end()){
                   cout<<"not found"<<endl;
         }else{
                   cout<<*it << endl;
         }
 
         void sort(iterator begin,iterator end,less cmp);
         less cmp： 比较器 （函数指针/函数对象实现比较规则）
         class CmpInt{
                   bool up;
                   public:
                   CmpInt(bool up = true):up(up){}
                   bool operator()(int a,int b) const{
                            return up?(b<a):(b>a);
                   }
         }
         bool cmpint(int a,int b){
                   return b< a;
         }
    ```
8. 由类类型对象组成的容器  
    * 缺省构造函数
    * 支持深拷贝的拷贝构造函数和拷贝复制运算符函数。
    * 如果需要查找，那么还需要支持‘==’运算符
    * 如果需要排序，那么还需要支持< 运算符，或者提供比较器  


###### 字符串  
```c++
string    #include <string>  string是一个模版实例的别名
 
template<typename T,...>
class basic_string{};
typedef basic_string<char> string;
ASNII/GBK/BIG5/UTF-8
```  
函数库iconv  
1. 实例化  
```c++
    string str;
   string str("");
   string str = "";
   string str = string("");
```
2. `str.c_str`
3. 计算  
    *  拼接 +
    * 赋值 =/+=  
4. 大小和容量  
    ```c++
       size ：获取字符数，不包括结尾空字符
       resize ：改变大小
       clear  ：清空
       empty  ：判断是否为空串
       capacity:获取容量
       reserve:改变容量，只增不减
       length：获取字符串长度
    ```  
5. 拼接  
    ```c++
     +/+=/
     string& append(const string& str);
    ```
6. 搜索 `size_type find_first_of(char cha,size_type pos=0);`  



###### 双端队列(deque)  
1. 双端队列的物理结构与向量几乎完全一样，唯一的区别就是双端队列的首尾两头都是开放的，都是压入和弹出数据
2. 接口与向量相比增加了push_front/pop_front函数，去掉了capacity/reserve函数
3. 性能方面，双端队列比向量要略差一点。内存消耗比向量多。对元素的访问时间比向量略长。
4. 空间的对称性决定了双端队列在首尾两端做通向操作的时间复杂度也是对成的。  

######  列表（list）  
1. 列表是按照链式线性表（链表）的形式进行存储的。
2. 在列表的任意位置做插入/删除都是常数时间。
3. 不支持下标运算符号。也不支持随机迭代。
4. 常用函数